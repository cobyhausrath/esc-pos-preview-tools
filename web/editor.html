<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESC-POS Receipt Editor - Powered by Pyodide</title>

    <!-- Pyodide -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            display: flex;
            height: 100vh;
            overflow: hidden;
            background: #1e1e1e;
            color: #d4d4d4;
        }

        .editor-pane {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .preview-pane {
            flex: 0 0 420px;
            border-left: 1px solid #3e3e3e;
            overflow-y: auto;
            background: #252526;
            display: flex;
            flex-direction: column;
        }

        .toolbar {
            padding: 12px;
            background: #2d2d30;
            border-bottom: 1px solid #3e3e3e;
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        .preview-header {
            padding: 16px;
            background: #2d2d30;
            border-bottom: 1px solid #3e3e3e;
        }

        .preview-header h3 {
            margin: 0;
            font-size: 14px;
            font-weight: 600;
            color: #cccccc;
        }

        .preview-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }

        #editor {
            flex: 1;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
            line-height: 1.6;
            padding: 16px;
            background: #1e1e1e;
            color: #d4d4d4;
            border: none;
            outline: none;
            resize: none;
            overflow-y: auto;
            white-space: pre;
            tab-size: 4;
        }

        #editor:focus {
            outline: none;
        }

        .status {
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .status.loading {
            background: #1a73e8;
            color: white;
        }

        .status.success {
            background: #0d7c2d;
            color: white;
        }

        .status.error {
            background: #c5221f;
            color: white;
        }

        .status.ready {
            background: #5f6368;
            color: white;
        }

        button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            background: #0e639c;
            color: white;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            transition: background 0.2s;
        }

        button:hover:not(:disabled) {
            background: #1177bb;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.secondary {
            background: #3e3e3e;
        }

        button.secondary:hover:not(:disabled) {
            background: #4e4e4e;
        }

        .receipt-container {
            background: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            width: 320px;  /* 80mm thermal paper width */
            max-width: 100%;
        }

        .receipt-content {
            padding: 20px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
            color: black;
            white-space: pre-wrap;  /* Changed from pre to pre-wrap for proper wrapping */
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .loading-spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .examples {
            display: flex;
            gap: 8px;
            margin-left: auto;
        }

        .receipt-line {
            margin: 0;
            padding: 0;
        }

        .receipt-line.center {
            text-align: center;
        }

        .receipt-line.right {
            text-align: right;
        }

        .error-message {
            color: #f48771;
            padding: 16px;
            font-family: monospace;
            font-size: 13px;
            line-height: 1.6;
            white-space: pre-wrap;
        }

        .size-wide, .size-double {
            letter-spacing: 0.2em;
            font-size: 1.5em;
            font-weight: bold;
        }

        .size-tall, .size-double {
            font-size: 2em;
            line-height: 1.2;
        }

        #file-input {
            display: none;
        }

        .toolbar-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .divider {
            width: 1px;
            height: 24px;
            background: #3e3e3e;
            margin: 0 4px;
        }

        /* HEX View Panel */
        .hex-panel {
            background: #1e1e1e;
            border-bottom: 1px solid #3e3e3e;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .hex-panel.visible {
            max-height: 400px;
            overflow-y: auto;
        }

        .hex-content {
            padding: 16px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 12px;
            line-height: 1.6;
            color: #d4d4d4;
            white-space: pre;
        }

        .hex-header {
            padding: 12px 16px;
            background: #2d2d30;
            border-bottom: 1px solid #3e3e3e;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .hex-header h4 {
            margin: 0;
            font-size: 13px;
            font-weight: 600;
            color: #cccccc;
        }

        .hex-stats {
            font-size: 12px;
            color: #858585;
        }

        .hex-offset {
            color: #858585;
        }

        .hex-bytes {
            color: #4ec9b0;
        }

        .hex-ascii {
            color: #ce9178;
        }

        button.toggle {
            background: transparent;
            border: 1px solid #3e3e3e;
        }

        button.toggle:hover:not(:disabled) {
            background: #3e3e3e;
            border-color: #4e4e4e;
        }

        button.toggle.active {
            background: #3e3e3e;
            border-color: #007acc;
        }

        /* Printer Controls */
        .printer-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        select {
            padding: 8px 12px;
            border: 1px solid #3e3e3e;
            border-radius: 4px;
            background: #2d2d30;
            color: #d4d4d4;
            cursor: pointer;
            font-size: 13px;
            outline: none;
        }

        select:hover {
            border-color: #4e4e4e;
        }

        select:focus {
            border-color: #007acc;
        }

        .connection-status {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
            color: #858585;
        }

        .connection-status.connected {
            color: #0d7c2d;
        }

        .connection-status.disconnected {
            color: #c5221f;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #858585;
        }

        .status-dot.connected {
            background: #0d7c2d;
        }

        .status-dot.disconnected {
            background: #c5221f;
        }
    </style>
</head>
<body>
    <div class="editor-pane">
        <div class="toolbar">
            <div class="toolbar-group">
                <button id="run-btn" title="Run (Ctrl+Enter)">
                    ‚ñ∂ Run
                </button>
                <button id="import-btn" class="secondary" title="Import ESC-POS file">
                    üìÅ Import
                </button>
                <button id="export-btn" class="secondary" title="Export to ESC-POS">
                    üíæ Export
                </button>
                <button id="share-btn" class="secondary" title="Copy shareable link to clipboard">
                    üîó Share
                </button>
                <button id="hex-toggle-btn" class="toggle" title="Toggle HEX view">
                    üîç HEX
                </button>
            </div>

            <div class="divider"></div>

            <div class="printer-controls">
                <select id="printer-select">
                    <option value="">Select printer...</option>
                    <option value="netum">Netum 80-V-UL</option>
                    <option value="custom">Custom IP...</option>
                </select>
                <button id="print-btn" class="secondary" title="Send to printer" disabled>
                    üñ®Ô∏è Print
                </button>
                <span class="connection-status disconnected" id="connection-status">
                    <span class="status-dot disconnected"></span>
                    Disconnected
                </span>
            </div>

            <div class="divider"></div>

            <div class="examples">
                <button id="example-simple" class="secondary">Simple</button>
                <button id="example-formatted" class="secondary">Formatted</button>
                <button id="example-receipt" class="secondary">Receipt</button>
            </div>

            <div class="divider"></div>

            <div id="status" class="status loading">
                <span class="loading-spinner"></span>
                Initializing Pyodide...
            </div>
        </div>
        <textarea id="editor" spellcheck="false"></textarea>
    </div>

    <div class="preview-pane">
        <!-- HEX View Panel (Collapsible) -->
        <div id="hex-panel" class="hex-panel">
            <div class="hex-header">
                <h4>HEX View</h4>
                <span class="hex-stats" id="hex-stats">0 bytes</span>
            </div>
            <div class="hex-content" id="hex-content">
                No data
            </div>
        </div>

        <!-- Receipt Preview -->
        <div class="preview-header">
            <h3>Receipt Preview (Live)</h3>
        </div>
        <div class="preview-content">
            <div id="preview">
                <div class="receipt-container">
                    <div class="receipt-content">Loading...</div>
                </div>
            </div>
        </div>
    </div>

    <input type="file" id="file-input" accept=".bin,.txt,*">

    <script type="module">
        // ===================================================================
        // Printer Client - WebSocket client for printer bridge
        // ===================================================================

        class PrinterClient {
            constructor(bridgeUrl = 'ws://127.0.0.1:8765') {
                this.bridgeUrl = bridgeUrl;
                this.ws = null;
                this.connected = false;
                this.printers = {};
                this.onStatusChange = null;
            }

            /**
             * Connect to printer bridge server
             * @returns {Promise<void>}
             */
            connect() {
                return new Promise((resolve, reject) => {
                    try {
                        this.ws = new WebSocket(this.bridgeUrl);

                        this.ws.onopen = () => {
                            console.log('Connected to printer bridge');
                            this.connected = true;
                            this.updateStatus('connected');
                        };

                        this.ws.onmessage = (event) => {
                            try {
                                const message = JSON.parse(event.data);
                                console.log('Bridge message:', message);

                                if (message.printers) {
                                    this.printers = message.printers;
                                }

                                if (message.success !== undefined) {
                                    // Response to a request
                                    if (this.onResponse) {
                                        this.onResponse(message);
                                    }
                                }
                            } catch (err) {
                                console.error('Failed to parse bridge message:', err);
                            }
                        };

                        this.ws.onclose = () => {
                            console.log('Disconnected from printer bridge');
                            this.connected = false;
                            this.updateStatus('disconnected');
                        };

                        this.ws.onerror = (error) => {
                            console.error('WebSocket error:', error);
                            this.connected = false;
                            this.updateStatus('disconnected');
                            reject(new Error('Failed to connect to printer bridge'));
                        };

                        // Wait for connection
                        const checkConnection = setInterval(() => {
                            if (this.connected) {
                                clearInterval(checkConnection);
                                resolve();
                            }
                        }, 100);

                        setTimeout(() => {
                            clearInterval(checkConnection);
                            if (!this.connected) {
                                reject(new Error('Connection timeout'));
                            }
                        }, 5000);

                    } catch (error) {
                        reject(error);
                    }
                });
            }

            /**
             * Disconnect from bridge
             */
            disconnect() {
                if (this.ws) {
                    this.ws.close();
                    this.ws = null;
                }
                this.connected = false;
                this.updateStatus('disconnected');
            }

            /**
             * Send data to printer
             * @param {string} printerName - Printer name or 'custom'
             * @param {Uint8Array} data - Binary data to send
             * @param {string} customHost - Custom host (if printerName is 'custom')
             * @param {number} customPort - Custom port (if printerName is 'custom')
             * @returns {Promise<{success: boolean, message?: string, error?: string}>}
             */
            sendToPrinter(printerName, data, customHost = null, customPort = null) {
                return new Promise((resolve, reject) => {
                    if (!this.connected) {
                        reject(new Error('Not connected to bridge'));
                        return;
                    }

                    const request = {
                        action: 'send',
                        data: Array.from(data)
                    };

                    if (printerName === 'custom') {
                        request.host = customHost;
                        request.port = customPort;
                    } else {
                        request.printer = printerName;
                    }

                    // Set response handler
                    this.onResponse = (message) => {
                        this.onResponse = null;
                        if (message.success) {
                            resolve(message);
                        } else {
                            reject(new Error(message.error || 'Unknown error'));
                        }
                    };

                    // Send request
                    this.ws.send(JSON.stringify(request));

                    // Timeout after 10 seconds
                    setTimeout(() => {
                        if (this.onResponse) {
                            this.onResponse = null;
                            reject(new Error('Request timeout'));
                        }
                    }, 10000);
                });
            }

            /**
             * Update connection status UI
             * @param {string} status - 'connected' or 'disconnected'
             */
            updateStatus(status) {
                if (this.onStatusChange) {
                    this.onStatusChange(status);
                }
            }
        }

        // ===================================================================
        // HEX Formatter - Display binary data as hex dump
        // ===================================================================

        class HexFormatter {
            /**
             * Format bytes as hex dump with offset, hex bytes, and ASCII
             * @param {Uint8Array} bytes - Binary data to format
             * @param {number} bytesPerLine - Bytes per line (default: 16)
             * @returns {string} Formatted hex dump
             */
            format(bytes, bytesPerLine = 16) {
                if (!bytes || bytes.length === 0) {
                    return 'No data';
                }

                let output = '';
                for (let i = 0; i < bytes.length; i += bytesPerLine) {
                    // Offset (8 hex digits)
                    const offset = i.toString(16).toUpperCase().padStart(8, '0');
                    output += `<span class="hex-offset">${offset}:</span> `;

                    // Hex bytes
                    const lineBytes = bytes.slice(i, i + bytesPerLine);
                    const hexPart = [];
                    for (let j = 0; j < bytesPerLine; j++) {
                        if (j < lineBytes.length) {
                            hexPart.push(lineBytes[j].toString(16).toUpperCase().padStart(2, '0'));
                        } else {
                            hexPart.push('  ');
                        }
                    }
                    output += `<span class="hex-bytes">${hexPart.join(' ')}</span>  `;

                    // ASCII representation
                    output += '| <span class="hex-ascii">';
                    for (let j = 0; j < lineBytes.length; j++) {
                        const byte = lineBytes[j];
                        // Printable ASCII or dot
                        const char = (byte >= 0x20 && byte <= 0x7E)
                            ? String.fromCharCode(byte)
                            : '.';
                        output += char;
                    }
                    output += '</span>\n';
                }

                return output;
            }

            /**
             * Get summary stats about the bytes
             * @param {Uint8Array} bytes - Binary data
             * @returns {string} Summary string
             */
            getStats(bytes) {
                if (!bytes || bytes.length === 0) {
                    return '0 bytes';
                }

                // Count command bytes (ESC, GS, etc.)
                let escCount = 0;
                let gsCount = 0;
                for (let i = 0; i < bytes.length; i++) {
                    if (bytes[i] === 0x1B) escCount++;
                    if (bytes[i] === 0x1D) gsCount++;
                }

                return `${bytes.length} bytes (ESC: ${escCount}, GS: ${gsCount})`;
            }
        }

        // ===================================================================
        // Receipt Editor - Main Application
        // ===================================================================

        class ReceiptEditor {
            constructor() {
                this.pyodide = null;
                this.debounceTimer = null;
                this.isReady = false;
                this.hexFormatter = new HexFormatter();
                this.hexVisible = false;
                this.printerClient = new PrinterClient();
                this.currentBytes = null; // Store last generated bytes
                this.selectedPrinter = '';

                // Setup printer client status callback
                this.printerClient.onStatusChange = (status) => {
                    this.updateConnectionStatus(status);
                };
            }

            /**
             * Encode code to base64 for URL hash
             * @param {string} code - The code to encode
             * @returns {string} Base64-encoded code
             */
            encodeCodeToHash(code) {
                try {
                    // Use btoa for base64 encoding, but first encode URI components
                    // to handle special characters properly
                    return btoa(encodeURIComponent(code));
                } catch (error) {
                    console.error('Failed to encode code:', error);
                    return '';
                }
            }

            /**
             * Decode code from base64 URL hash
             * @param {string} hash - The base64 hash string
             * @returns {string|null} Decoded code or null if invalid
             */
            decodeCodeFromHash(hash) {
                try {
                    // Decode base64 and then decode URI components
                    return decodeURIComponent(atob(hash));
                } catch (error) {
                    console.error('Failed to decode hash:', error);
                    return null;
                }
            }

            /**
             * Get code from URL hash parameter
             * @returns {string|null} Code from hash or null
             */
            getCodeFromHash() {
                const hash = window.location.hash;
                if (!hash || hash.length <= 1) {
                    return null;
                }

                // Remove '#' and parse parameter
                const params = new URLSearchParams(hash.substring(1));
                const codeParam = params.get('code');

                if (!codeParam) {
                    return null;
                }

                return this.decodeCodeFromHash(codeParam);
            }

            /**
             * Update URL hash with current code
             * @param {string} code - The code to save in hash
             */
            updateHash(code) {
                const encoded = this.encodeCodeToHash(code);
                if (encoded) {
                    // Use replaceState to avoid adding to browser history
                    const newHash = `#code=${encoded}`;
                    window.history.replaceState(null, '', newHash);
                }
            }

            async init() {
                try {
                    this.updateStatus('loading', 'Loading Pyodide...');

                    // Load Pyodide
                    this.pyodide = await loadPyodide({
                        indexURL: "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/"
                    });

                    this.updateStatus('loading', 'Installing python-escpos...');

                    // Install python-escpos
                    await this.pyodide.loadPackage("micropip");
                    const micropip = this.pyodide.pyimport("micropip");
                    await micropip.install("python-escpos");

                    this.updateStatus('success', 'Ready!');
                    this.isReady = true;

                    console.log('init: Pyodide ready, checking for hash parameters');

                    // Enable buttons
                    document.getElementById('run-btn').disabled = false;
                    document.getElementById('import-btn').disabled = false;
                    document.getElementById('export-btn').disabled = false;
                    document.getElementById('share-btn').disabled = false;

                    // Load code from hash if present, otherwise load default example
                    const codeFromHash = this.getCodeFromHash();
                    if (codeFromHash) {
                        console.log('init: Loading code from hash parameter');
                        document.getElementById('editor').value = codeFromHash;
                        this.runCode();
                    } else {
                        console.log('init: No hash parameter, loading default example');
                        this.loadExample('simple');
                    }
                    console.log('init: Complete');

                } catch (error) {
                    this.updateStatus('error', `Failed to initialize: ${error.message}`);
                    console.error(error);
                }
            }

            updateStatus(type, message) {
                const statusEl = document.getElementById('status');
                statusEl.className = `status ${type}`;

                if (type === 'loading') {
                    statusEl.innerHTML = `<span class="loading-spinner"></span>${message}`;
                } else {
                    statusEl.textContent = message;
                }
            }

            async runCode() {
                if (!this.isReady) {
                    console.log('runCode: Not ready yet');
                    return;
                }

                const code = document.getElementById('editor').value;
                console.log('runCode: Executing code, length:', code.length);

                try {
                    this.updateStatus('loading', 'Executing...');

                    // Execute python-escpos code in Pyodide
                    const result = await this.pyodide.runPythonAsync(`
from escpos.printer import Dummy
import sys
from io import StringIO

# Capture any print statements
old_stdout = sys.stdout
sys.stdout = StringIO()

result = None
try:
    # Create namespace for user code
    namespace = {'Dummy': Dummy}

    # Execute user code in namespace (using JSON.stringify for safe escaping)
    exec(${JSON.stringify(code)}, namespace)

    # Get the printer instance from namespace
    p = namespace.get('p')
    if p is None:
        raise Exception("Code must create a printer instance named 'p'")

    # Get ESC-POS output
    result = list(p.output)

except Exception as e:
    raise Exception(f"Execution error: {str(e)}")
finally:
    sys.stdout = old_stdout

result
                    `);

                    console.log('runCode: Result type:', typeof result);
                    console.log('runCode: Result:', result);

                    // Convert to Uint8Array
                    const escposBytes = new Uint8Array(result);
                    console.log('runCode: Bytes length:', escposBytes.length);
                    console.log('runCode: First 20 bytes:', Array.from(escposBytes.slice(0, 20)));

                    // Store bytes for printing
                    this.currentBytes = escposBytes;

                    // Update HEX view
                    this.updateHexView(escposBytes);

                    // Render preview
                    this.renderPreview(escposBytes);

                    this.updateStatus('success', `‚úì Success (${escposBytes.length} bytes)`);

                    // Update print button state
                    this.updateConnectionStatus(this.printerClient.connected ? 'connected' : 'disconnected');

                } catch (error) {
                    this.updateStatus('error', `‚úó Error`);
                    this.showError(error.message);
                    console.error('runCode error:', error);
                }
            }

            /**
             * Update the HEX view panel with new bytes
             * @param {Uint8Array} bytes - Binary data to display
             */
            updateHexView(bytes) {
                const hexContent = document.getElementById('hex-content');
                const hexStats = document.getElementById('hex-stats');

                hexContent.innerHTML = this.hexFormatter.format(bytes);
                hexStats.textContent = this.hexFormatter.getStats(bytes);
            }

            /**
             * Toggle HEX view visibility
             */
            toggleHexView() {
                this.hexVisible = !this.hexVisible;
                const hexPanel = document.getElementById('hex-panel');
                const hexToggleBtn = document.getElementById('hex-toggle-btn');

                if (this.hexVisible) {
                    hexPanel.classList.add('visible');
                    hexToggleBtn.classList.add('active');
                } else {
                    hexPanel.classList.remove('visible');
                    hexToggleBtn.classList.remove('active');
                }
            }

            /**
             * Connect to printer bridge
             */
            async connectToBridge() {
                try {
                    await this.printerClient.connect();
                    console.log('Connected to printer bridge');
                    return true;
                } catch (error) {
                    console.error('Failed to connect to bridge:', error);
                    return false;
                }
            }

            /**
             * Update connection status UI
             * @param {string} status - 'connected' or 'disconnected'
             */
            updateConnectionStatus(status) {
                const statusEl = document.getElementById('connection-status');
                const statusDot = statusEl.querySelector('.status-dot');
                const printBtn = document.getElementById('print-btn');

                statusEl.className = `connection-status ${status}`;
                statusDot.className = `status-dot ${status}`;
                statusEl.innerHTML = `
                    <span class="status-dot ${status}"></span>
                    ${status === 'connected' ? 'Connected' : 'Disconnected'}
                `;

                // Enable/disable print button based on connection and bytes available
                printBtn.disabled = !(status === 'connected' && this.currentBytes && this.currentBytes.length > 0);
            }

            /**
             * Send current bytes to printer
             */
            async sendToPrinter() {
                if (!this.currentBytes || this.currentBytes.length === 0) {
                    alert('No data to print. Run the code first.');
                    return;
                }

                if (!this.printerClient.connected) {
                    alert('Not connected to printer bridge. Make sure printer-bridge is running.');
                    return;
                }

                const printerSelect = document.getElementById('printer-select');
                const printerName = printerSelect.value;

                if (!printerName) {
                    alert('Please select a printer first.');
                    return;
                }

                try {
                    this.updateStatus('loading', 'Sending to printer...');

                    if (printerName === 'custom') {
                        const host = prompt('Enter printer IP address:', '192.168.1.100');
                        if (!host) return;

                        const portStr = prompt('Enter printer port:', '9100');
                        const port = parseInt(portStr, 10);
                        if (isNaN(port)) {
                            alert('Invalid port number');
                            return;
                        }

                        const result = await this.printerClient.sendToPrinter('custom', this.currentBytes, host, port);
                        this.updateStatus('success', `‚úì Printed ${result.bytesSent} bytes`);
                    } else {
                        const result = await this.printerClient.sendToPrinter(printerName, this.currentBytes);
                        this.updateStatus('success', `‚úì Printed ${result.bytesSent} bytes`);
                    }

                } catch (error) {
                    this.updateStatus('error', `Print failed: ${error.message}`);
                    alert(`Print failed: ${error.message}`);
                }
            }

            renderPreview(escposBytes) {
                // Simple ESC-POS parser and renderer
                console.log('renderPreview: Called with', escposBytes.length, 'bytes');
                const preview = document.getElementById('preview');

                let html = '<div class="receipt-container"><div class="receipt-content">';
                let currentAlign = 'left';
                let currentBold = false;
                let currentUnderline = false;
                let currentLine = '';
                let i = 0;
                let lineCount = 0;

                while (i < escposBytes.length) {
                    const byte = escposBytes[i];

                    // ESC sequences
                    if (byte === 0x1B && i + 1 < escposBytes.length) {
                        const cmd = escposBytes[i + 1];

                        // ESC @ - Initialize
                        if (cmd === 0x40) {
                            i += 2;
                            continue;
                        }

                        // ESC a - Alignment
                        if (cmd === 0x61 && i + 2 < escposBytes.length) {
                            if (currentLine) {
                                html += this.formatLine(currentLine, currentAlign, currentBold, currentUnderline);
                                lineCount++;
                                currentLine = '';
                            }
                            const align = escposBytes[i + 2];
                            currentAlign = align === 1 ? 'center' : align === 2 ? 'right' : 'left';
                            i += 3;
                            continue;
                        }

                        // ESC E - Bold
                        if (cmd === 0x45 && i + 2 < escposBytes.length) {
                            currentBold = escposBytes[i + 2] !== 0;
                            i += 3;
                            continue;
                        }

                        // ESC - - Underline
                        if (cmd === 0x2D && i + 2 < escposBytes.length) {
                            currentUnderline = escposBytes[i + 2] !== 0;
                            i += 3;
                            continue;
                        }

                        i += 2;
                        continue;
                    }

                    // GS sequences
                    if (byte === 0x1D && i + 1 < escposBytes.length) {
                        const cmd = escposBytes[i + 1];

                        // GS V - Cut
                        if (cmd === 0x56 && i + 2 < escposBytes.length) {
                            if (currentLine) {
                                html += this.formatLine(currentLine, currentAlign, currentBold, currentUnderline);
                                lineCount++;
                                currentLine = '';
                            }
                            html += '<div class="receipt-line center">--- ‚úÇ ---</div>';
                            lineCount++;
                            i += 3;
                            continue;
                        }

                        i += 2;
                        continue;
                    }

                    // Line feed
                    if (byte === 0x0A) {
                        html += this.formatLine(currentLine, currentAlign, currentBold, currentUnderline);
                        lineCount++;
                        currentLine = '';
                        i++;
                        continue;
                    }

                    // Printable ASCII
                    if (byte >= 0x20 && byte <= 0x7E) {
                        currentLine += String.fromCharCode(byte);
                        i++;
                        continue;
                    }

                    // Skip other bytes
                    i++;
                }

                // Flush remaining line
                if (currentLine) {
                    html += this.formatLine(currentLine, currentAlign, currentBold, currentUnderline);
                    lineCount++;
                }

                html += '</div></div>';
                console.log('renderPreview: Generated', lineCount, 'lines');
                console.log('renderPreview: HTML length:', html.length);
                console.log('renderPreview: HTML preview:', html.substring(0, 200));
                preview.innerHTML = html;
                console.log('renderPreview: Done');
            }

            /**
             * Format a line of receipt text with styling
             * @param {string} text - The text content
             * @param {string} align - Alignment: 'left', 'center', or 'right'
             * @param {boolean} bold - Whether text should be bold
             * @param {boolean} underline - Whether text should be underlined
             * @returns {string} HTML string for the formatted line
             */
            formatLine(text, align, bold, underline) {
                if (!text && text !== '') return '';

                let style = '';
                if (bold) text = `<strong>${text}</strong>`;
                if (underline) text = `<u>${text}</u>`;

                return `<div class="receipt-line ${align}">${text || '&nbsp;'}</div>`;
            }

            showError(message) {
                const preview = document.getElementById('preview');
                preview.innerHTML = `
                    <div class="receipt-container">
                        <div class="error-message">Error:\n${this.escapeHtml(message)}</div>
                    </div>
                `;
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            loadExample(name) {
                console.log('loadExample:', name);
                const examples = {
                    simple: `from escpos.printer import Dummy

# Create printer
p = Dummy()

# Simple receipt
p.text('Hello, World!\\n')
p.text('This is a test receipt.\\n')
`,

                    formatted: `from escpos.printer import Dummy

# Create printer
p = Dummy()

# Formatted text
p.set(align='center')
p.set(bold=True)
p.text('FORMATTED TEXT\\n')
p.set(bold=False)

p.text('\\n')

p.set(align='left')
p.text('Normal text\\n')

p.set(bold=True)
p.text('Bold text\\n')
p.set(bold=False)

p.set(underline=1)
p.text('Underlined text\\n')
p.set(underline=0)

p.text('\\n')

p.set(align='center')
p.text('Centered text\\n')

p.set(align='right')
p.text('Right-aligned\\n')
`,

                    receipt: `from escpos.printer import Dummy

# Create printer
p = Dummy()

# Store header
p.set(align='center')
p.set(bold=True)
p.set(width=2, height=2)
p.text('COFFEE SHOP\\n')
p.set(width=1, height=1)
p.set(bold=False)
p.text('123 Main Street\\n')
p.text('Tel: (555) 123-4567\\n')

p.text('\\n')

# Receipt details
p.set(align='left')
p.text('Date: 2024-01-15 14:30\\n')
p.text('Order #: 1234\\n')

p.text('\\n')
p.text('--------------------------------\\n')

# Items
p.text('Cappuccino           $4.50\\n')
p.text('Croissant            $3.25\\n')
p.text('Latte                $4.75\\n')

p.text('--------------------------------\\n')

# Total
p.set(bold=True)
p.text('TOTAL:              $12.50\\n')
p.set(bold=False)

p.text('\\n')

# Footer
p.set(align='center')
p.text('Thank you!\\n')
p.text('Please come again\\n')

p.text('\\n')

# Cut paper
p.cut(mode='FULL')
`
                };

                document.getElementById('editor').value = examples[name];
                console.log('loadExample: Set editor value, isReady:', this.isReady);
                if (this.isReady) {
                    console.log('loadExample: Calling onCodeChange');
                    this.onCodeChange();
                }
            }

            onCodeChange() {
                console.log('onCodeChange: Debouncing...');
                clearTimeout(this.debounceTimer);
                this.debounceTimer = setTimeout(() => {
                    console.log('onCodeChange: Debounce complete, calling runCode and updating hash');
                    const code = document.getElementById('editor').value;
                    this.updateHash(code);
                    this.runCode();
                }, 500); // 500ms debounce
            }

            async importFile(file) {
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const bytes = new Uint8Array(arrayBuffer);

                    // For now, just display the raw bytes
                    // In future, use the verifier to convert to Python
                    this.renderPreview(bytes);
                    this.updateStatus('success', `Imported ${bytes.length} bytes`);

                } catch (error) {
                    this.updateStatus('error', `Import failed: ${error.message}`);
                }
            }

            async exportFile() {
                try {
                    const code = document.getElementById('editor').value;

                    // Execute code to get ESC-POS bytes
                    const result = await this.pyodide.runPythonAsync(`
from escpos.printer import Dummy
p = Dummy()
exec(${JSON.stringify(code)})
list(p.output)
                    `);

                    const bytes = new Uint8Array(result);

                    // Create blob and download
                    const blob = new Blob([bytes], { type: 'application/octet-stream' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'receipt.bin';
                    a.click();
                    URL.revokeObjectURL(url);

                    this.updateStatus('success', `‚úì Exported ${bytes.length} bytes`);

                } catch (error) {
                    this.updateStatus('error', `Export failed: ${error.message}`);
                }
            }

            /**
             * Share the current code by copying URL to clipboard
             */
            async shareCode() {
                try {
                    const code = document.getElementById('editor').value;

                    // Update hash to ensure URL is current
                    this.updateHash(code);

                    // Copy current URL to clipboard
                    const url = window.location.href;
                    await navigator.clipboard.writeText(url);

                    // Show success message
                    const originalStatus = document.getElementById('status').textContent;
                    this.updateStatus('success', '‚úì Link copied to clipboard!');

                    // Restore original status after 2 seconds
                    setTimeout(() => {
                        if (this.isReady) {
                            this.updateStatus('success', originalStatus);
                        }
                    }, 2000);

                } catch (error) {
                    this.updateStatus('error', `Share failed: ${error.message}`);
                }
            }
        }

        // ===================================================================
        // Initialize Application
        // ===================================================================

        const editor = new ReceiptEditor();

        window.addEventListener('load', async () => {
            // Setup event listeners and get button references
            const editorEl = document.getElementById('editor');
            const runBtn = document.getElementById('run-btn');
            const importBtn = document.getElementById('import-btn');
            const exportBtn = document.getElementById('export-btn');
            const shareBtn = document.getElementById('share-btn');
            const hexToggleBtn = document.getElementById('hex-toggle-btn');
            const printBtn = document.getElementById('print-btn');
            const printerSelect = document.getElementById('printer-select');
            const fileInput = document.getElementById('file-input');

            // Disable buttons until ready
            runBtn.disabled = true;
            importBtn.disabled = true;
            exportBtn.disabled = true;
            shareBtn.disabled = true;
            printBtn.disabled = true;

            // Run button
            runBtn.addEventListener('click', () => editor.runCode());

            // Auto-run on change
            editorEl.addEventListener('input', () => editor.onCodeChange());

            // Ctrl+Enter to run
            editorEl.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                    e.preventDefault();
                    editor.runCode();
                }
            });

            // Tab key support
            editorEl.addEventListener('keydown', (e) => {
                if (e.key === 'Tab') {
                    e.preventDefault();
                    const start = editorEl.selectionStart;
                    const end = editorEl.selectionEnd;
                    editorEl.value = editorEl.value.substring(0, start) + '    ' + editorEl.value.substring(end);
                    editorEl.selectionStart = editorEl.selectionEnd = start + 4;
                }
            });

            // Import button
            importBtn.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    editor.importFile(e.target.files[0]);
                }
            });

            // Export button
            exportBtn.addEventListener('click', () => editor.exportFile());

            // Share button
            shareBtn.addEventListener('click', () => editor.shareCode());

            // HEX toggle button
            hexToggleBtn.addEventListener('click', () => editor.toggleHexView());

            // Print button
            printBtn.addEventListener('click', () => editor.sendToPrinter());

            // Printer select
            printerSelect.addEventListener('change', (e) => {
                editor.selectedPrinter = e.target.value;
            });

            // Example buttons
            document.getElementById('example-simple').addEventListener('click', () => editor.loadExample('simple'));
            document.getElementById('example-formatted').addEventListener('click', () => editor.loadExample('formatted'));
            document.getElementById('example-receipt').addEventListener('click', () => editor.loadExample('receipt'));

            // Initialize editor (this will enable buttons when ready)
            await editor.init();

            // Try to connect to printer bridge (optional)
            // This will fail silently if bridge is not running
            setTimeout(async () => {
                try {
                    await editor.connectToBridge();
                } catch (error) {
                    console.log('Printer bridge not available (this is okay)');
                }
            }, 1000);

            // Expose for debugging
            window.receiptEditor = editor;
        });
    </script>
</body>
</html>
